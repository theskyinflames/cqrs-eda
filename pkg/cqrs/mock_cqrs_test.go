// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cqrs_test

import (
	"context"
	"github.com/theskyinflames/cqrs-eda/pkg/bus"
	"github.com/theskyinflames/cqrs-eda/pkg/cqrs"
	"sync"
)

// Ensure, that CommandMock does implement cqrs.Command.
// If this is not the case, regenerate this file with moq.
var _ cqrs.Command = &CommandMock{}

// CommandMock is a mock implementation of cqrs.Command.
//
//	func TestSomethingThatUsesCommand(t *testing.T) {
//
//		// make and configure a mocked cqrs.Command
//		mockedCommand := &CommandMock{
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedCommand in code that requires cqrs.Command
//		// and then make assertions.
//
//	}
type CommandMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *CommandMock) Name() string {
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	if mock.NameFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedCommand.NameCalls())
func (mock *CommandMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Ensure, that QueryMock does implement cqrs.Query.
// If this is not the case, regenerate this file with moq.
var _ cqrs.Query = &QueryMock{}

// QueryMock is a mock implementation of cqrs.Query.
//
//	func TestSomethingThatUsesQuery(t *testing.T) {
//
//		// make and configure a mocked cqrs.Query
//		mockedQuery := &QueryMock{
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedQuery in code that requires cqrs.Query
//		// and then make assertions.
//
//	}
type QueryMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *QueryMock) Name() string {
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	if mock.NameFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedQuery.NameCalls())
func (mock *QueryMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Ensure, that CommandHandlerMock does implement cqrs.CommandHandler.
// If this is not the case, regenerate this file with moq.
var _ cqrs.CommandHandler = &CommandHandlerMock{}

// CommandHandlerMock is a mock implementation of cqrs.CommandHandler.
//
//	func TestSomethingThatUsesCommandHandler(t *testing.T) {
//
//		// make and configure a mocked cqrs.CommandHandler
//		mockedCommandHandler := &CommandHandlerMock{
//			HandleFunc: func(ctx context.Context, cmd cqrs.Command) ([]cqrs.Event, error) {
//				panic("mock out the Handle method")
//			},
//		}
//
//		// use mockedCommandHandler in code that requires cqrs.CommandHandler
//		// and then make assertions.
//
//	}
type CommandHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(ctx context.Context, cmd cqrs.Command) ([]cqrs.Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cmd is the cmd argument value.
			Cmd cqrs.Command
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *CommandHandlerMock) Handle(ctx context.Context, cmd cqrs.Command) ([]cqrs.Event, error) {
	callInfo := struct {
		Ctx context.Context
		Cmd cqrs.Command
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	if mock.HandleFunc == nil {
		var (
			eventsOut []cqrs.Event
			errOut    error
		)
		return eventsOut, errOut
	}
	return mock.HandleFunc(ctx, cmd)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//
//	len(mockedCommandHandler.HandleCalls())
func (mock *CommandHandlerMock) HandleCalls() []struct {
	Ctx context.Context
	Cmd cqrs.Command
} {
	var calls []struct {
		Ctx context.Context
		Cmd cqrs.Command
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// Ensure, that QueryHandlerMock does implement cqrs.QueryHandler.
// If this is not the case, regenerate this file with moq.
var _ cqrs.QueryHandler = &QueryHandlerMock{}

// QueryHandlerMock is a mock implementation of cqrs.QueryHandler.
//
//	func TestSomethingThatUsesQueryHandler(t *testing.T) {
//
//		// make and configure a mocked cqrs.QueryHandler
//		mockedQueryHandler := &QueryHandlerMock{
//			HandleFunc: func(ctx context.Context, q cqrs.Query) (cqrs.QueryResult, error) {
//				panic("mock out the Handle method")
//			},
//		}
//
//		// use mockedQueryHandler in code that requires cqrs.QueryHandler
//		// and then make assertions.
//
//	}
type QueryHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(ctx context.Context, q cqrs.Query) (cqrs.QueryResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q cqrs.Query
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *QueryHandlerMock) Handle(ctx context.Context, q cqrs.Query) (cqrs.QueryResult, error) {
	callInfo := struct {
		Ctx context.Context
		Q   cqrs.Query
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	if mock.HandleFunc == nil {
		var (
			queryResultOut cqrs.QueryResult
			errOut         error
		)
		return queryResultOut, errOut
	}
	return mock.HandleFunc(ctx, q)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//
//	len(mockedQueryHandler.HandleCalls())
func (mock *QueryHandlerMock) HandleCalls() []struct {
	Ctx context.Context
	Q   cqrs.Query
} {
	var calls []struct {
		Ctx context.Context
		Q   cqrs.Query
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// Ensure, that BusMock does implement cqrs.Bus.
// If this is not the case, regenerate this file with moq.
var _ cqrs.Bus = &BusMock{}

// BusMock is a mock implementation of cqrs.Bus.
//
//	func TestSomethingThatUsesBus(t *testing.T) {
//
//		// make and configure a mocked cqrs.Bus
//		mockedBus := &BusMock{
//			DispatchFunc: func(contextMoqParam context.Context, dispatchable bus.Dispatchable) (interface{}, error) {
//				panic("mock out the Dispatch method")
//			},
//		}
//
//		// use mockedBus in code that requires cqrs.Bus
//		// and then make assertions.
//
//	}
type BusMock struct {
	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(contextMoqParam context.Context, dispatchable bus.Dispatchable) (interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Dispatchable is the dispatchable argument value.
			Dispatchable bus.Dispatchable
		}
	}
	lockDispatch sync.RWMutex
}

// Dispatch calls DispatchFunc.
func (mock *BusMock) Dispatch(contextMoqParam context.Context, dispatchable bus.Dispatchable) (interface{}, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Dispatchable    bus.Dispatchable
	}{
		ContextMoqParam: contextMoqParam,
		Dispatchable:    dispatchable,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	if mock.DispatchFunc == nil {
		var (
			ifaceValOut interface{}
			errOut      error
		)
		return ifaceValOut, errOut
	}
	return mock.DispatchFunc(contextMoqParam, dispatchable)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//
//	len(mockedBus.DispatchCalls())
func (mock *BusMock) DispatchCalls() []struct {
	ContextMoqParam context.Context
	Dispatchable    bus.Dispatchable
} {
	var calls []struct {
		ContextMoqParam context.Context
		Dispatchable    bus.Dispatchable
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}
